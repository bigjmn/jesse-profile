
  <body>
    <div class="d-flex justify-content-center mt-2 projtitle"><h2>Q Maze Solver</h2></div>



    <div class="container-fluid">
      <iframe id='mazeframe' src="https://bigjmn.github.io/q-maze-bot/" ></iframe>


    </div>

    <div class="container-fluid">
      <div class="d-flex justify-content-center  mb-3">





      <div class="context text-end pt-5">the project

      </div>
      <div class="p-5 content" >
        <p>The best way to understand this particular project is to mess around with it for a couple minutes. Hit 'run' to start. </p>
        <p>  Q Mazebot is an AI that solves mazes using reinforcement learning techniques. The user creates the maze (or picks on from a bank of random mazes) and Q Mazebot sets off, updating the ‘value’ of each square as it searches for the finish line. Every move Q Mazebot moves to the adjacent square with the highest value (closest to zero, as all values are negative) with ties broken randomly. The value of the square it leaves is updated to be one less than its highest-rated neighbor. You can see how Mazebot values each square by the square’s color - the darker the red, the worse Mazebot values that square. When Mazebot finds the finish line, he starts over from the beginning, but the square values don’t reset. Eventually Mazebot will be able to solve the maze the fastest possible way. The maze can also feature a key that must be picked up to open a corresponding gate. </p><p>

  The graph tracks the number of steps it takes Mazebot to complete the maze. Mazebot will usually get worse before he gets better. Eventually Mazebot will complete the maze the same way every time - the fastest way. Use the slider to set Mazebot’s step speed. For big mazes (and even not so big mazes) you’ll want this set pretty high.
        </p>

<p>Check out the <a id='gitlink' href="http://github.com/bigjmn/q-maze-bot">Github repo.</a> </p>







      </div>
        </div>

        <div class="d-flex justify-content-center  mb-3">





        <div class="context text-end pt-5">what I used

        </div>
        <div class="p-5 content" ><p>For the basic interface I used a lot of JQuery. The actual maze is an array of buttons - I used some mouse down/up/move listeners to enable the user to essentially ‘draw’ the maze they want rather than have to toggle the buttons one at a time. The buttons were given ids dynamically corresponding to their positions in the DOM tree. This made it easier to translate the user-selected inputs of the GUI’ maze to a more abstract layer that the program could manipulate more easily.</p><p> This abstract layer is created only when the user ‘locks in’ the maze and runs the simulation. The elements of the abstract layer - maze squares and Mazebot - each have as a property a JQuery selector that accesses their corresponding GUI components.

For graphing the progress, I used Plotly. </p>







        </div>
          </div>

          <div class="d-flex justify-content-center  mb-3">





          <div class="context text-end pt-5">thoughts

          </div>
          <div class="p-5 content" ><p>Mazebot solves mazes - there’s no denying that. There’s also something oddly satisfying (and slightly hypnotic) about watching it at work. At the same time, there’s something about it that really bugs me.
</p><p>
It’s slow.</p>
<p>
It’s true that my algorithm is slow, but I actually like my algorithm. It’s very similar to Bellman Ford or Djikstra or any other greedy BFS shortest path algorithm, but pared down to fit within the parameters of what the AI knows. This is an important distinction - when we see Mazebot solve the maze, we’re seeing the entire environment at once. Mazebot can only ‘see’ the squares immediately around him, and can only update square values when he visits them. It’s  much harder to solve a maze from the inside. Still, the algorithm is ‘complete’ - one can show with a neat little proof by induction (similar to the proof for Djikstra and others) that the optimal path will always be found. All in all, my main concern is not with the maze-solving methodology.</p>

The AI is slow because it’s designed to be slow. It’s tethered to the animation. Mazebot’s learning process - updating square values and traversing the virtual maze - is wrapped up in the callback function of the JQuery animation. This massively throttles the learning rate, and that’s what has to happen for us to watch Mazebot learn. Essentially I’m denying the computer its greatest asset - computing. Running thousands of simulations per second. That’s why watching Mazebot take a few minutes to solve a 15x15 maze feels unnaturally slow - because it <i>is</i> unnaturally slow.
<br><br>
I do have plans for Mazebot. But things are gonna go sideways.







          </div>
            </div>

            <div class="d-flex justify-content-center  mb-3">





            <div class="context text-end pt-5">next steps

            </div>
            <div class="p-5 content" >I’m ditching the key/gate thing. It doesn’t add much, and it’s basically just putting two mazes next to each other - one from the start to the key and the next from the key to the end. Also the way mazebot sees only his immediate surroundings. Also the square valuations. Also the javascript. And there’s going to be a few minotaurs, and around a thousand Mazebots. <br><br> Like I said, things are going sideways.
<br><br>
The issue with maze solving: it’s static. Which makes it pretty boring. The minotaur livens things up. The goal becomes escaping the maze as quickly as possible without colliding with a (randomly moving) minotaur. The fact that the minotaurs move randomly is important - it allows us to run tons of simulations concurrently. The learning method I’m currently designing involves genetic algorithms and a good amount of Tensorflow, so I’ll actually be switching to python. In Hemmingway 6 word novel form, the plan is: ‘breed Mazebots, isolate minotaur evasion gene’. If that sounds interesting, check out the link <a href="https://colab.research.google.com/drive/1npJplBzKTKqzHt_qoV2OW4jr0OiKkmR5?usp=sharing">project notebook.</a>







            </div>
              </div>






    </div>





  </body>
